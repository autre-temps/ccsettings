---
name: commit
description: >
  このPythonプロジェクトに対して、安全にGitコミットを準備・作成します。
  ユーザーが「commit」「コミットして」「commitしたい」と言ったときや、
  変更のステージング、コミットの分割、ruff/pytestチェック、コミットメッセージ作成を依頼したときに使用します。
disable-model-invocation: true
argument-hint: "[任意: 短い目的 / issue-id]"
---

# /commit — 安全なコミット手順（Python: ruff + pytest / uv run）

## 目的
*小さく、レビューしやすく、ポリシーに沿った*コミットを作成する：
- 意図しないファイルや秘密情報が含まれない
- ruff / pytest が通る（失敗時は原因と対処を示す）
- コミットメッセージが規約に沿う（既定：Conventional Commits 風）

> 入力（任意）：`$ARGUMENTS`（例：「ログインのバグ修正」「issue-123」「typingのリファクタ」）

---

## 前提（このリポジトリ固有）
- 依存・実行は `uv run` を使用する
- フォーマットは「編集後に自動整形するフック」が既にある（原則、フォーマッタを走らせて差分を増やさない）
  - ただしコミット直前の保険として *チェックのみ* を行うのは可

---

## 運用ルール（必ず守る）
1. **明示的な確認なしに、自動でコミットしない。**
   - コマンド提案はしてよいが、コミット前に必ず「この内容で commit してよいですか？」と確認する。
2. **秘密情報を絶対に含めない。**
   - 差分に認証情報/鍵/トークンの可能性（例：`API_KEY=`、`SECRET=`、`BEGIN PRIVATE KEY` 等）が見えたら停止し、
     除去・ローテーション手順を案内する。
3. **1つの大きなコミットより、複数の小さなコミットを優先する。**
   - 変更目的が複数ある場合は、分割プラン（ディレクトリ/機能/関心事ごと）を提案する。

---

## 手順（ステップ・バイ・ステップ）

### 0) 状態確認とスコープ把握
- 実行する：
  - `git status`
  - `git diff`
  - `git diff --staged`
- 3つの箇条書きで要約する：
  1) 何が変わったか（高レベル）
  2) 影響範囲・リスク
  3) 怪しい／意図していないファイル（巨大バイナリ、lockfile、秘密情報、生成物など）

### 1) 変更の整理（分割が必要か判断）
- diff の中から論理的なまとまりを見つける（例）：
  - 純粋なフォーマット/スタイル（※原則コミットに混ぜない。混ざっていたら分離を検討）
  - 振る舞いを変えないリファクタ
  - バグ修正 / 機能追加
  - テスト / ドキュメントのみ
- 分割が望ましい場合、以下を使った具体的な手順を提案する：
  - `git add -p`
  - `git add <paths>`
  - （任意）調整用に `git restore --staged <paths>`

次のような **コミット構成案** を出力する：
- Commit A：<目的>（paths…）
- Commit B：<目的>（paths…）

### 2) チェック（uv run / ruff + pytest）
> 基本は「チェックのみ」。編集後フックで自動整形される前提なので、
> フォーマット実行で差分を増やすことは避ける。

- 必須：
  - `uv run ruff check .`
  - `uv run pytest -q`

- 任意（保険の“チェックのみ”）：
  - もし ruff format を使っている場合：`uv run ruff format --check .`
    - ※差分が出るなら、フックが効いていない/対象外のファイルがある可能性を示し、
      コミット前に整形する方針（ユーザーの運用）に従って対処を提案する

- 何かが失敗したら：
  - ありがちな原因を示す
  - 次に取るべき最小限の修正案を提示する
  - ユーザーが回避策を承認するか、修正が適用されるまで **コミットは進めない**

### 3) コミットメッセージ案の作成
このリポジトリに別ルールがない限り、既定フォーマットは次：
- `type(scope): summary`
- 空行
- 任意の本文：what/why、制約
- 任意のフッター：`Refs: #123` または `Fixes: #123`

**許可する `type`（既定）：**
- feat, fix, refactor, perf, docs, test, chore, ci, build

ルール：
- summary は命令形、72文字以内
- 必要ならユーザーの意図や `$ARGUMENTS` を反映する
- 分割コミットなら、コミットごとにメッセージ案を作る

**候補を3つ**提示し、推奨案を1つ選ぶ。

### 4) 最終確認ゲート（必須）
コミット前に必ず：
1) 次を提示する：
   - `git diff --staged` の要約
   - 提案するメッセージ
   - 実行する `git commit -m ...`（またはエディタ起動型）コマンド
2) 確認する：
   - 「この内容で commit してよいですか？（はい/いいえ）」
3) 「はい」の場合のみ：
   - commit コマンドを実行する
   - commit 後に次を表示する：
     - `git log -1 --oneline`
     - 未ステージ変更が残っているか（あれば表示）

### 5) 任意の後続対応
ユーザーが求めた場合：
- `git push` の対象（`origin <branch>`）を提案するが、push 前にも必ず確認を取る。

---

## 出力フォーマット（常にこの形式で）
### Commit readiness
- 状態：✅ Ready / ⚠️ 要修正 / ⛔ 停止（秘密情報/意図しないファイル）
- 重要な所見（3つ）

### Suggested staging
- プラン（分割案、または「単一コミットでOK」）
- コマンド

### Checks
- 実行コマンド（結果も要約）
- 失敗内容＋修正提案（ある場合）

### Commit message
- 推奨メッセージ
- 代替案（2つ）

### Confirmation question
- 「この内容で commit してよいですか？」
